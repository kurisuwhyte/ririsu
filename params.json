{"name":"Ririsu","tagline":"A pure untyped parallel distributed stack-based dynamically-scoped data-processing esolang.","body":"Ririsu is a small concatenative esolang that's perfect for code-golfs. It's even less readable than PERL!\r\n\r\nFor example, here's how you could solve the [100 Doors problem](http://rosettacode.org/wiki/100_doors):\r\n\r\n```text\r\n[1+[^[f]~[1~-]~2>!?],r]p@[001]vp[s^o=]|\r\n```\r\n\r\n## Installing\r\n\r\nRirisu is implemented in [Erlang](http://www.erlang.org/), so you'll need that to run anything. Once you've got that sorted out, just clone the repository:\r\n\r\n```bash\r\n$ git clone git://github.com/kurisuwhyte/ririsu\r\n$ cd ririsu\r\n$ make\r\n```\r\n\r\nNow, just run `bin/ririsu repl` to get thrown in a delicious Read-Eval-Print-Loop.\r\n\r\n## Warming up\r\n\r\nSo, now that you have a REPL we can try running some code. First, Ririsu is a concatenative language, this means that everything works on top of a stack. Some commands will push data on the stack, and some will use the top values of the stack to do computation, and push the result back on the stack.\r\n\r\nFor example, addition would work like this:\r\n\r\n```bash\r\nririsu> 12+\r\n[\"3\"]\r\n```\r\n\r\nThe previous operation is evaluated as follows:\r\n\r\n```text\r\nWe start with an empty stack: []\r\n\"1\" gets pushed on the stack: [\"1\"]\r\n\"2\" gets pushed on the stack: [\"2\", \"1\"]\r\n\"+\" operates on the top two values, and pushes the result back: \"2\" + \"1\" => [\"3\"]\r\n```\r\n\r\n> **Note:** Ririsu is untyped, so you can shoot yourself in the foot without realising you're shooting yourself in the foot, yay!\r\n\r\n## Down the rabbit hole\r\n\r\nOkay, if you ever heard about [RPN](http://en.wikipedia.org/wiki/Reverse_Polish_notation) that was no biggie. So let's get to the interesting stuff. In Ririsu you can use code as data, and data as code. The stack is always what you use to pass arguments to functions, and these arguments can be code (yes, yes, Higher-Order functions and all that).\r\n\r\nTo treat code as data, you have to \"Quote\" it, so that it won't be executed just yet:\r\n\r\n```text\r\nririsu> [12+]\r\n[[\"1\", \"2\", \"+\"]]\r\n```\r\n\r\nWe can execute any list using the operation `$`:\r\n\r\n```text\r\nririsu> $\r\n[\"3\"]\r\n```\r\n\r\nNow things start getting interesting, since you can pass code around, and you can evaluate it, it means we can do Higher-Order functions! Some of them are already core-coded for your convenience, like Map:\r\n\r\n```text\r\nririsu> [123456]\r\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"], [\"3\"]]\r\nririsu> [1+]|\r\n[[\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"], [\"3\"]]\r\n```\r\n\r\n## Manipulate the stack, they said. It'll be fun, they said...\r\n\r\nSometimes you'll need to manipulate the stack so that the operation you're applying gets arguments in the correct order. Operations are really just functions that take in a Stack and return a new Stack â€” in Ririsu, though, you also get **dynamic scoping**, since functions also take an environment.\r\n\r\nSuppose you want to check if the square root of a value is an exact number. You could do it by cloning items on the stack:\r\n\r\n```text\r\nririsu> 5s\r\n[2.23606797749979]\r\nririsu> ^\r\n[2.23606797749979,2.23606797749979]\r\nririsu> o\r\n[2,2.23606797749979]\r\nririsu> =\r\n[false]\r\n```\r\n\r\nOr you can use the dynamic scoping madness:\r\n\r\n```text\r\nririsu> 5sA@\r\n[]  # just stored `5s` in `A`\r\nririsu> AAo=\r\n[false]\r\n```\r\n\r\n> **Note:** Sadly, Erlang doesn't support unicode :(\r\n\r\n## What else?\r\n\r\nThe whole documentation for the language can be found in the seat pocket in front of you... I mean, in the `docs/` directory. There's also a handful of `examples/` laying around. The [Concatenative Wiki](http://concatenative.org/wiki/view/Front%20Page) is an amazing place to learn more about concatenative programming in general :)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}